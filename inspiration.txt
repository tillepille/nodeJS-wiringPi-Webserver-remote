wiringPi documentation{
digitalWrite(pin, state)

>= 0.1.0

Write the value HIGH (1) or LOW (0) to the given pin which must have been previously set as an output.

WiringPi treats any non-zero number as HIGH, however 0 is the only representation of LOW.

state can be one of the following value:

HIGH >= 0.1.2
LOW >= 0.1.2


}




github.com/xkonni/raspberry-remote

daemon{
piHiPri(20);
mySwitch = RCSwitch();
mySwitch.setPulseLength(300);
usleep(50000);
mySwitch.enableTransmit(0);
intertechnoCodeforTriState () {
    char pSystemCode[14];
    switch(atoi(nGroup)){
        // house/family code A=1 - P=16
        case 1:     { printf("1/A ... ");	    strcpy(pSystemCode,"0000");	break; }
        case 2:     { printf("2/B ... ");	    strcpy(pSystemCode,"F000");	break; }
        case 3:	    { printf("3/C ... ");	    strcpy(pSystemCode,"0F00");	break; }
        case 4:     { printf("4/D ... ");	    strcpy(pSystemCode,"FF00");	break; }
        case 5:	    { printf("5/E ... ");	    strcpy(pSystemCode,"00F0");	break; }
        case 6:     { printf("6/F ... ");	    strcpy(pSystemCode,"F0F0");	break; }
        case 7:	    { printf("7/G ... ");	    strcpy(pSystemCode,"0FF0");	break; }
        case 8:     { printf("8/H ... ");	    strcpy(pSystemCode,"FFF0");	break; }
        case 9:	    { printf("9/I ... ");	    strcpy(pSystemCode,"000F");	break; }
        case 10:    { printf("10/J ... ");	    strcpy(pSystemCode,"F00F");	break; }
        case 11:	{ printf("11/K ... ");	    strcpy(pSystemCode,"0F0F");	break; }
        case 12:    { printf("12/L ... ");	    strcpy(pSystemCode,"FF0F");	break; }
        case 13:	{ printf("13/M ... ");	    strcpy(pSystemCode,"00FF");	break; }
        case 14:    { printf("14/N ... ");	    strcpy(pSystemCode,"F0FF");	break; }
        case 15:	{ printf("15/O ... ");	    strcpy(pSystemCode,"0FFF");	break; }
        case 16:    { printf("16/P ... ");	    strcpy(pSystemCode,"FFFF");	break; }
        default:{
            printf("systemCode[%s] is unsupported\n", nGroup);
        return -1;
        }
    }
    printf("got systemCode[%s] ",nGroup);
    switch(nSwitchNumber){
        // unit/group code 01-16
        case 1:     { printf("1 ... ");	    strcat(pSystemCode,"0000");	break; }

        case 3:	    { printf("3 ... ");	    strcat(pSystemCode,"0F00");	break; }
        case 4:     { printf("4 ... ");	    strcat(pSystemCode,"FF00");	break; }
        case 5:	    { printf("5 ... ");	    strcat(pSystemCode,"00F0");	break; }
        case 6:     { printf("6 ... ");	    strcat(pSystemCode,"F0F0");	break; }
        case 7:	    { printf("7 ... ");	    strcat(pSystemCode,"0FF0");	break; }
        case 8:     { printf("8 ... ");	    strcat(pSystemCode,"FFF0");	break; }
        case 9:	    { printf("9 ... ");	    strcat(pSystemCode,"000F");	break; }
        case 10:    { printf("10 ... ");	    strcat(pSystemCode,"F00F");	break; }
        case 11:	{ printf("11 ... ");	    strcat(pSystemCode,"0F0F");	break; }
        case 12:    { printf("12 ... ");	    strcat(pSystemCode,"FF0F");	break; }
        case 13:	{ printf("13 ... ");	    strcat(pSystemCode,"00FF");	break; }
        case 14:    { printf("14 ... ");	    strcat(pSystemCode,"F0FF");	break; }
        case 15:	{ printf("15 ... ");	    strcat(pSystemCode,"0FFF");	break; }
        case 16:    { printf("16 ... ");	    strcat(pSystemCode,"FFFF");	break; }
        default:{
            printf("unitCode[%i] is unsupported\n", nSwitchNumber);
            return -1;
        }
    }
    strcat(pSystemCode,"0F"); // mandatory bits
    switch(nAction){
        case 0:{
            strcat(pSystemCode,"F0");
            mySwitch.sendTriState(pSystemCode);
            printf("sent TriState signal: pSystemCode[%s]\n",pSystemCode);
            nState[nAddr] = 0;
            //sprintf(msg, "nState[%d] = %d", nAddr, nState[nAddr]);
            sprintf(msg, "%d", nState[nAddr]);
            n = write(newsockfd,msg,1);
        break;
        }
        case 1:{
            strcat(pSystemCode,"FF");
            mySwitch.sendTriState(pSystemCode);
        }
    }
}

}

rcswitch{

// for ELRO switches with binary numbering

void RCSwitch::switchOffBinary(char* sGroup, int nChannel) {
  this->sendTriState( this->getCodeWordD(sGroup, nChannel, false) );
}


char* RCSwitch::getCodeWordD(char* sGroup, int nChannelCode, boolean bStatus) {
   int nReturnPos = 0;
   static char sReturn[13];

  /**
   * The codeword, that needs to be sent, consists of three main parts:
   * char 0 to 4: Group-Number (already binary)
   * char 5 to 9: Socket Number (converted to binary, former: the socket number 0-5 sets the only active bit in the return string)
   *              e.g: socket 1 means: bit 1 is on, others off: 10000
   *                   socket 5 means: bit 4 is on, others off: 00010
   *              now: real binary representation of decimal socket number
   * char 10 to 11: Power state, where on means '01' and off means '10'
  */

  //const char* code[6] = { "FFFFF", "0FFFF", "F0FFF", "FF0FF", "FFF0F", "FFFF0" }; //former conversion of socket number to binary

  if (nChannelCode < 1 || nChannelCode > 31) {
      return '\0';
  }

  for (int i = 0; i<5; i++) {
    if (sGroup[i] == '0') {
      sReturn[nReturnPos++] = 'F';
    } else if (sGroup[i] == '1') {
      sReturn[nReturnPos++] = '0';
    } else {
      return '\0';
    }
  }

  std::string str = std::bitset<5>(nChannelCode).to_string();
  std::string temp = str;
  for(std::string::size_type i = 0; i < str.size(); ++i) {
    if (str[i] == '0') {
      sReturn[nReturnPos++] = 'F';
    } else if (str[i] == '1') {
      sReturn[nReturnPos++] = '0';
    }
  }
  //Status
  if (bStatus) {
    sReturn[nReturnPos++] = '0';
    sReturn[nReturnPos++] = 'F';
  } else {
    sReturn[nReturnPos++] = 'F';
    sReturn[nReturnPos++] = '0';
  }
  sReturn[nReturnPos] = '\0';
  //std::cout << sReturn;
  return sReturn;
}


void RCSwitch::sendTriState(char* sCodeWord) {
  for (int nRepeat=0; nRepeat<nRepeatTransmit; nRepeat++) {
    int i = 0;
    while (sCodeWord[i] != '\0') {
      switch(sCodeWord[i]) {
        case '0':
          this->sendT0();
        break;
        case 'F':
          this->sendTF();
        break;
        case '1':
          this->sendT1();
        break;
      }
      i++;
    }
    this->sendSync();
}

void RCSwitch::sendT0() {
  this->transmit(1,3);
  this->transmit(1,3);
}

/**
 * Sends a Tri-State "1" Bit
 *            ___   ___
 * Waveform: |   |_|   |_
 */
void RCSwitch::sendT1() {
  this->transmit(3,1);
  this->transmit(3,1);
}

    /**
     * Sends a Tri-State "F" Bit
     *            _     ___
     * Waveform: | |___|   |_
     */
void RCSwitch::sendTF() {
  this->transmit(1,3);
  this->transmit(3,1);
}

void RCSwitch::sendSync() {
    if (this->nProtocol == 1){
    this->transmit(1,31);
  }
  else if (this->nProtocol == 2) {
    this->transmit(1,10);
  }
}



void RCSwitch::transmit(int nHighPulses, int nLowPulses) {
    boolean disabled_Receive = false;
    int nReceiverInterrupt_backup = nReceiverInterrupt;
    if (this->nTransmitterPin != -1) {
        if (this->nReceiverInterrupt != -1) {
            this->disableReceive();
            disabled_Receive = true;
        }
        for(int i=0; i<nHighPulses; i++) {
          digitalWrite(this->nTransmitterPin, HIGH);
          delayMicroseconds( this->nPulseLength);
        }
        for(int i=0; i<nLowPulses; i++) {
          digitalWrite(this->nTransmitterPin, LOW);
          delayMicroseconds( this->nPulseLength);
        }
        if(disabled_Receive){
            this->enableReceive(nReceiverInterrupt_backup);
        }
    }
}



}
